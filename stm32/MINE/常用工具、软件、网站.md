# 常用工具、软件、网站

常用仪器仪表：万用表；示波器；稳压电源

软件：MXcube vscode Keil

网站：CSDN GitHub 半导小芯 （查芯片手册）

# 单片机

32位系统（如int长度不同）

芯片手册

# GPIO

通用输入输出 完成高低电频输入输出 ABCD四组 每组16个引脚

Output Push pull

三种模式：不上拉不下拉 上拉 下拉

# 外部中断

处理完毕后返回

中断优先级

# 实际操作

1、直接操作寄存器

2、标准库

3、HAL库 

创建new project

选择芯片 stm32 F103C8T6

魔术棒：debug→settings→Flash download→reset and run

Application/User/core→main.c

写在begin和end之间

上升沿 下降沿

函数弱定义

# 中断应用

`void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)`

`{`

​	`if (GPIO_Pin==GPIO_Pin_13){`pwm_value++;



`}`

# 定时器

timer

## 关注问题

位宽 计数值 处理

## 主要功能

### 定时计数 

### 输出比较 

PWM 电平翻转

###  输入捕获



CK_CNT=CK_PSC/(PSC+1)

T(s)=(ARR+1)*(PSC+1)/TIM_CLK(Hz)

## 相关函数

  /* USER CODE BEGIN 2 */
	__HAL_TIM_CLEAR_IT(&htim4,TIM_IT_UPDATE);
	HAL_TIM_Base_Start_IT(&htim4);
  /* USER CODE END 2 */

/* USER CODE BEGIN 4 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
	if(TIM4==htim->Instance){
		HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13);
		}
	}

/* USER CODE END 4 */



## PWM

  /* USER CODE BEGIN 2 */
	HAL_TIM_PWM_Start(&htim4 ,TIM_CHANNEL_1);
  /* USER CODE END 2 */

    /* USER CODE BEGIN 3 */
    	for(int i = 0;i<10000;i+=20)
    	{
    	__HAL_TIM_SetCompare(&htim4,TIM_CHANNEL_1,i);
    	HAL_Delay(1);
    	}
    }
  /* USER CODE END 3 */



# 串口通信

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "usart.h"
#include "gpio.h"
#include "retarget.h"

printf scanf重定向：

`#ifndef	__RETARGET_H
#define	__RETARGET_H`

`#include "stm32f1xx.h"`

`#include "usart.h"`

`#include <stdio.h>`
`#include <string.h>`
`#include <stdarg.h>`

`#define _USART1 1	                                //串口1开关`
`#define _USART2 0	                                //串口2开关`
`#define _USART3 0	                                //串口3开关`

`#define BUFFER_MAX_SIZE         512`
`static char USART_BUFFER[BUFFER_MAX_SIZE];`

`#if _USART1`
    `#define printf(FORMAT,...) \`
    `{\`
        `memset(USART_BUFFER, 0, BUFFER_MAX_SIZE);\`
        `sprintf(USART_BUFFER,FORMAT,##__VA_ARGS__); \`
	    `HAL_UART_Transmit(&huart1,(uint8_t *)USART_BUFFER,strlen(USART_BUFFER), 1);\`
    `}`
`#else`
    `#define printf(FORMAT,...)`
`#endif`

`#if _USART2`
    `#define printf2(FORMAT,...) \`
    `{\`
        `memset(USART_BUFFER, 0, BUFFER_MAX_SIZE);\`
        `sprintf(USART_BUFFER,FORMAT,##__VA_ARGS__); \`
	    `HAL_UART_Transmit(&huart2,(uint8_t *)USART_BUFFER,strlen(USART_BUFFER), 1);\`
    `}`
`#else`
    `#define printf2(FORMAT,...)`
`#endif`

`#if _USART3`
    `#define printf3(FORMAT,...) \`
    `{\`
    `memset(USART_BUFFER, 0, BUFFER_MAX_SIZE);\`
    `sprintf(USART_BUFFER,FORMAT,##__VA_ARGS__); \`
	`HAL_UART_Transmit(&huart3,(uint8_t *)USART_BUFFER,strlen(USART_BUFFER), 1);\`
    `}`
`#else`
    `#define printf3(FORMAT,...)`
`#endif`

`#endif`

*// -----------------------------------------------------------------------//*
*/\* USER CODE BEGIN PD \*/*
\#define LENGTH 10     *// 接收数据缓冲区大小*
*/\* USER CODE END PD \*/*

*// -----------------------------------------------------------------------//*
*/\* USER CODE BEGIN PV \*/*
uint8_t RxBuffer[LENGTH]; *// 接收缓冲区*
uint8_t RxFlag = 0;    *// 接收完成标志，0未完成，1完成*
*/\* USER CODE END PV \*/*

*// -----------------------------------------------------------------------//*
 */\* USER CODE BEGIN 2 \*/*
 *// 打印提示信息*
 printf("UART Communication Using IT\n");
 printf("Please enter 10 characters:\n");
 HAL_UART_Receive_IT(&huart1, (uint8_t *)RxBuffer, LENGTH); *// 使能接收中断*
 */\* USER CODE END 2 \*/*

*// -----------------------------------------------------------------------//*
 while (1)
 {
  */\* USER CODE BEGIN 3 \*/*
  if (RxFlag == 1)  *// 判断接收是否完成*
  {
   RxFlag = 0;   *// 接收完成，清除标志位*
   printf("Receive Successfully!\n"); *// 打印提示信息*
   HAL_UART_Transmit_IT(&huart1, (uint8_t*)RxBuffer, LENGTH); *// 将接收的字符原样发回*
  }
 }
 */\* USER CODE END 3 \*/*

*// -----------------------------------------------------------------------//*
*/\* USER CODE BEGIN 4 \*/*
int fputc(int ch, FILE *f)
{
 HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
 return ch;
}

int fgetc(FILE *f)
{
 uint8_t ch = 0;
 HAL_UART_Receive(&huart1, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
 return ch;
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 if (huart->Instance == USART1) *// 判断发生接收中断的串口*
 {
  RxFlag = 1; *// 置位接收完成b标志*
  HAL_UART_Receive_IT(&huart1, (uint8_t*)RxBuffer, LENGTH); *// 使能接收中断*
 }
}
*/\* USER CODE END 4 \*/*
*// -----------------------------------------------------------------------//*